const { checkAndRefreshAccessToken } = require('../lib/oauth');
const cardBuilder = require('../lib/cardBuilder');
const { RcUserModel } = require('../models/rcUserModel');
const { ReplySettingModel } = require('../models/replySettingModel');
const rcAPI = require('../lib/rcAPI');
const moment = require('moment');

async function notification(req, res) {
    try {
        const data = req.body.body;
        console.log(`Posted message: ${JSON.stringify(data, null, 2)}`);
        const rcUserId = req.query.userId;
        const rcUser = await RcUserModel.findByPk(rcUserId);
        if (!rcUser) {
            res.status(404);
            res.send('User Not Found')
            return;
        }
        await checkAndRefreshAccessToken(rcUser);
        const replySetting = await ReplySettingModel.findByPk(rcUser.replySettingId);
        if (!replySetting) {
            res.status(404);
            res.send('Response Settings Not Found')
            return;
        }
        // Team Message
        if (data && data.groupId) {
            const groupResponse = await rcAPI.getChat(data.groupId, rcUser.accessToken);
            if (groupResponse.type == 'Direct') {
                if (groupResponse.id != rcUser.rcDMGroupId && data.creatorId != rcUser.id) {
                    await responseToUser(data.groupId, rcUser, replySetting, 'This is a Direct Message auto-response message generated by Ring Bot');
                }
            }
            else {
                if (replySetting.enableGroupMentionResponse && data.mentions && data.mentions.some(m => m.id == rcUserId)) {
                    const dmGroupToCreator = await rcAPI.createConversation([data.creatorId], rcUser.accessToken);
                    await responseToUser(dmGroupToCreator.id, rcUser, replySetting, 'This is a Group Mention auto-response message generated by Ring Bot');
                }
            }
        }
        // SMS
        else if (replySetting.smsOn && data && data.type == 'SMS') {
            const senderNumber = data.from.phoneNumber;
            const myNumber = data.to[0].phoneNumber;
            const smsMessage = replySetting.smsReply;
            await rcAPI.sendSMS(smsMessage, myNumber, senderNumber, rcUser.accessToken);
        }
    }
    catch (e) {
        console.error(e);
    }

    if (req.headers['validation-token']) {
        res.header('validation-token', req.headers['validation-token']);
    }

    res.status(200);
    res.json({
        result: 'OK',
    });
}

async function responseToUser(groupId, rcUser, replySetting, warning) {
    const nowDate = new Date();
    // Replying within date range (Off Work) overrides other settings
    if (replySetting.outOfOfficeStartDate && replySetting.outOfOfficeEndDate && moment(nowDate).utc().isBetween(moment(replySetting.outOfOfficeStartDate), moment(replySetting.outOfOfficeEndDate), null, "[]")) {
        const outOfOfficeResponseCard = cardBuilder.responseCard(
            replySetting.outOfOfficeReply,
            warning);
        await rcAPI.createCardInChat(groupId, rcUser.accessToken, outOfOfficeResponseCard);
    }
    // Busy and Offline state
    else {
        const userPresenceResponse = await rcAPI.getUserSelfPresence(rcUser.accessToken);
        switch (userPresenceResponse.status) {
            case 'Available':
                break;
            case 'Busy':
            case 'DND':
                if (replySetting.busyOn) {
                    const busyResponseCard = cardBuilder.responseCard(
                        replySetting.busyReply,
                        warning);
                    await rcAPI.createCardInChat(groupId, rcUser.accessToken, busyResponseCard);
                }
                break;
            case 'Offline':
                if (replySetting.offlineOn) {
                    const offlineResponseCard = cardBuilder.responseCard(
                        replySetting.offlineReply,
                        warning);
                    await rcAPI.createCardInChat(groupId, rcUser.accessToken, offlineResponseCard);
                }
                break;
        }
    }
}

exports.notification = notification;