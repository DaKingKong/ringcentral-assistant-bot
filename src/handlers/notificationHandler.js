const { checkAndRefreshAccessToken } = require('../lib/oauth');
const cardBuilder = require('../lib/cardBuilder');
const { RcUserModel } = require('../models/rcUserModel');
const { ReplySettingModel } = require('../models/replySettingModel');
const { ReplyRecordModel } = require('../models/replyRecordModel');
const rcAPI = require('../lib/rcAPI');
const moment = require('moment');

const AUTO_REPLY_MUTE_BUFFER_MINUTES = 15;

async function notification(req, res) {
    try {
        const data = req.body.body;
        console.log(`Posted message: ${JSON.stringify(data, null, 2)}`);
        if (data.eventType != 'PostAdded') {
            res.status(200);
            res.json({ result: 'OK', });
            return;
        }
        const rcUserId = req.query.userId;
        const rcUser = await RcUserModel.findByPk(rcUserId);
        if (!rcUser) {
            res.status(404);
            res.send('User Not Found')
            return;
        }
        // check if message creator is a bot -> If yes, do nothing
        const userInfo = await rcAPI.getUserInfo(data.creatorId, rcUser.accessToken);
        if (userInfo.email && userInfo.email.endsWith('.bot.glip.net')) {
            res.status(200);
            res.json({ result: 'OK', });
            console.log('Message from bot, ignore...');
            return;
        }
        await checkAndRefreshAccessToken(rcUser);
        const replySetting = await ReplySettingModel.findByPk(rcUser.replySettingId);
        if (!replySetting) {
            res.status(404);
            res.send('Response Settings Not Found')
            return;
        }
        let isMute = true;
        // Team Message
        if (data && data.groupId) {
            const groupResponse = await rcAPI.getChat(data.groupId, rcUser.accessToken);
            if (groupResponse.type == 'Direct') {
                if (groupResponse.id != rcUser.rcDMGroupId && data.creatorId != rcUser.id) {
                    isMute = await checkAndUpdateAutoReplyMuteBuffer(data.creatorId, rcUser.id);
                    if (!isMute) {
                        await responseToUser(data.groupId, rcUser, replySetting, 'This is a Direct Message auto-response message generated by Ring Bot');
                    }
                }
            }
            else {
                if (replySetting.enableGroupMentionResponse && data.mentions && data.mentions.some(m => m.id == rcUserId)) {
                    const dmGroupToCreator = await rcAPI.createConversation([data.creatorId], rcUser.accessToken);
                    await responseToUser(dmGroupToCreator.id, rcUser, replySetting, 'This is a Group Mention auto-response message generated by Ring Bot');
                }
            }
        }
        // SMS
        else if (replySetting.smsOn && data && data.type == 'SMS') {
            const senderNumber = data.from.phoneNumber;
            const myNumber = data.to[0].phoneNumber;
            const smsMessage = replySetting.smsReply;
            await rcAPI.sendSMS(smsMessage, myNumber, senderNumber, rcUser.accessToken);
        }
    }
    catch (e) {
        console.error(e);
    }

    if (req.headers['validation-token']) {
        res.header('validation-token', req.headers['validation-token']);
    }

    res.status(200);
    res.json({
        result: 'OK',
    });
}

// 15min mute after 1st message sent
async function checkAndUpdateAutoReplyMuteBuffer(senderId, receiverId) {
    const replyRecordId = `${senderId}-${receiverId}`;
    const existingReplyRecord = await ReplyRecordModel.findByPk(replyRecordId);
    const nowDate = moment(new Date());
    if (existingReplyRecord) {
        // case 1: within 15min -> MUTE
        if (nowDate.isBefore(moment(existingReplyRecord.expiry))) {
            return true;
        }

        // case 2: over 15min -> SEND -> UPDATE
        existingReplyRecord.expiry = nowDate.add(AUTO_REPLY_MUTE_BUFFER_MINUTES, 'minutes').toDate();
        await existingReplyRecord.save();
    }
    else {
        // case 3: 1st message -> SEND -> CREATE
        await ReplyRecordModel.create({
            id: replyRecordId,
            expiry: nowDate.add(AUTO_REPLY_MUTE_BUFFER_MINUTES, 'minutes').toDate()
        })
    }
    return false;
}

async function responseToUser(groupId, rcUser, replySetting, warning) {
    const nowDate = new Date();
    // Replying within date range (Off Work) overrides other settings
    if (replySetting.outOfOfficeStartDate && replySetting.outOfOfficeEndDate && moment(nowDate).utc().isBetween(moment(replySetting.outOfOfficeStartDate), moment(replySetting.outOfOfficeEndDate), null, "[]")) {
        const outOfOfficeResponseCard = cardBuilder.responseCard(
            replySetting.outOfOfficeReply,
            warning);
        await rcAPI.createCardInChat(groupId, rcUser.accessToken, outOfOfficeResponseCard);
    }
    // Busy and Offline state
    else {
        const userPresenceResponse = await rcAPI.getUserSelfPresence(rcUser.accessToken);
        switch (userPresenceResponse.status) {
            case 'Available':
                break;
            case 'Busy':
            case 'DND':
                if (replySetting.busyOn) {
                    const busyResponseCard = cardBuilder.responseCard(
                        replySetting.busyReply,
                        warning);
                    await rcAPI.createCardInChat(groupId, rcUser.accessToken, busyResponseCard);
                }
                break;
            case 'Offline':
                if (replySetting.offlineOn) {
                    const offlineResponseCard = cardBuilder.responseCard(
                        replySetting.offlineReply,
                        warning);
                    await rcAPI.createCardInChat(groupId, rcUser.accessToken, offlineResponseCard);
                }
                break;
        }
    }
}

exports.notification = notification;