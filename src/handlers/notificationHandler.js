const { checkAndRefreshAccessToken } = require('../lib/oauth');
const cardBuilder = require('../lib/cardBuilder');
const Bot = require('ringcentral-chatbot-core/dist/models/Bot').default;
const { RcUserModel } = require('../models/rcUserModel');
const { ReplySettingModel } = require('../models/replySettingModel');
const { ReplyRecordModel } = require('../models/replyRecordModel');
const rcAPI = require('../lib/rcAPI');
const moment = require('moment');
const { WatchUserModel } = require('../models/watchUserModel');

const AUTO_REPLY_MUTE_BUFFER_MINUTES = 15;

async function notification(req, res) {
    if (req.headers['validation-token']) {
        res.header('validation-token', req.headers['validation-token']);
    }

    try {
        const data = req.body.body;
        if (data == null) {
            res.status(200);
            res.json({ result: 'OK' });
            return;
        }
        console.log(`Incoming notification: ${JSON.stringify(data, null, 2)}`);
        let notificationType = '';
        if (data.eventType == 'PostAdded') {
            notificationType = 'post';
        }
        else if (data.presenceStatus) {
            notificationType = 'presence';
        }
        else {
            res.status(200);
            res.json({ result: 'OK' });
            return;
        }
        const rcUserId = req.query.userId;
        const rcUser = await RcUserModel.findByPk(rcUserId);
        if (!rcUser) {
            res.status(200);
            res.send('User Not Found')
            return;
        }
        await checkAndRefreshAccessToken(rcUser);
        // case 1: presence change
        if (notificationType == 'presence') {
            if (data.presenceStatus == 'Available') {
                const watchId = `${rcUser.id}-${data.extensionId}`;
                const watch = await WatchUserModel.findByPk(watchId);
                const watchPresenceCard = cardBuilder.responseCard(`${watch.watcheeName} has just become **Available**. This watch will be automatically cleared.`, '');
                const bot = await Bot.findByPk(rcUser.botId);
                await bot.sendAdaptiveCard(rcUser.rcDMGroupId, watchPresenceCard);
                await rcAPI.deleteWebHook(watch.webhookId, rcUser.accessToken);
                await watch.destroy();
            }
            res.status(200);
            res.json({ result: 'OK' });
            return;
        }

        // case 2: new posts
        // check if message creator is a bot -> If yes, do nothing
        const userInfo = await rcAPI.getUserInfo(data.creatorId, rcUser.accessToken);
        if (userInfo.email && userInfo.email.endsWith('.bot.glip.net')) {
            res.status(200);
            res.json({ result: 'OK', });
            console.log('Message from bot, ignore...');
            return;
        }
        const replySetting = await ReplySettingModel.findByPk(rcUser.replySettingId);
        if (!replySetting) {
            res.status(200);
            res.send('Response Settings Not Found')
            return;
        }
        // Team Message
        if (data && data.groupId) {
            const groupResponse = await rcAPI.getChat(data.groupId, rcUser.accessToken);
            if (groupResponse.type == 'Direct') {
                if (groupResponse.id != rcUser.rcDMGroupId && data.creatorId != rcUser.id) {
                    // 15min mute after 1st message sent
                    let isMute = true;
                    const replyRecordId = `${data.creatorId}-${rcUser.id}`;
                    const existingReplyRecord = await ReplyRecordModel.findByPk(replyRecordId);
                    const nowDate = moment(new Date());
                    if (existingReplyRecord) {
                        isMute = nowDate.isBefore(moment(existingReplyRecord.expiry));
                    }
                    else {
                        isMute = false;
                    }
                    if (!isMute) {
                        await responseToUser(data.groupId, rcUser, replySetting, 'This is a Direct Message auto-response message generated by Ring Bot');
                        // UPDATE/CREATE record
                        if (existingReplyRecord) {
                            existingReplyRecord.expiry = nowDate.add(AUTO_REPLY_MUTE_BUFFER_MINUTES, 'minutes').toDate();
                            await existingReplyRecord.save();
                        }
                        else {
                            await ReplyRecordModel.create({
                                id: replyRecordId,
                                expiry: nowDate.add(AUTO_REPLY_MUTE_BUFFER_MINUTES, 'minutes').toDate()
                            })
                        }
                    }
                }
            }
            else {
                if (replySetting.enableGroupMentionResponse && data.mentions && data.mentions.some(m => m.id == rcUserId)) {
                    const dmGroupToCreator = await rcAPI.createConversation([data.creatorId], rcUser.accessToken);
                    await responseToUser(dmGroupToCreator.id, rcUser, replySetting, 'This is a Group Mention auto-response message generated by Ring Bot');
                }
            }
        }
        // SMS
        else if (replySetting.smsOn && data && data.type == 'SMS') {
            const senderNumber = data.from.phoneNumber;
            const myNumber = data.to[0].phoneNumber;
            const smsMessage = replySetting.smsReply;
            await rcAPI.sendSMS(smsMessage, myNumber, senderNumber, rcUser.accessToken);
        }
    }
    catch (e) {
        console.error(e);
    }

    res.status(200);
    res.json({
        result: 'OK',
    });
}

async function responseToUser(groupId, rcUser, replySetting, warning) {
    const nowDate = new Date();
    // Replying within date range (Off Work) overrides other settings
    if (replySetting.outOfOfficeStartDate && replySetting.outOfOfficeEndDate && moment(nowDate).utc().isBetween(moment(replySetting.outOfOfficeStartDate), moment(replySetting.outOfOfficeEndDate), null, "[]")) {
        const outOfOfficeResponseCard = cardBuilder.responseCard(
            replySetting.outOfOfficeReply,
            warning);
        await rcAPI.createCardInChat(groupId, rcUser.accessToken, outOfOfficeResponseCard);
    }
    // Busy and Offline state
    else {
        const userPresenceResponse = await rcAPI.getUserSelfPresence(rcUser.accessToken);
        switch (userPresenceResponse.status) {
            case 'Available':
                break;
            case 'Busy':
            case 'DND':
                if (replySetting.busyOn) {
                    const busyResponseCard = cardBuilder.responseCard(
                        replySetting.busyReply,
                        warning);
                    await rcAPI.createCardInChat(groupId, rcUser.accessToken, busyResponseCard);
                }
                break;
            case 'Offline':
                if (replySetting.offlineOn) {
                    const offlineResponseCard = cardBuilder.responseCard(
                        replySetting.offlineReply,
                        warning);
                    await rcAPI.createCardInChat(groupId, rcUser.accessToken, offlineResponseCard);
                }
                break;
        }
    }
}

exports.notification = notification;